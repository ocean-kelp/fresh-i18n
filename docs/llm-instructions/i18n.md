# i18n Usage Guide (@xiayun/fresh-i18n)

This guide covers recommended patterns for using the Fresh i18n plugin effectively.

## Quick Reference

```tsx
// Routes - use state.t directly
const t = state.t;
t("common.actions.save"); // âœ…

// Islands - NEW RECOMMENDED WAY (v0.3.0+)
import { useTranslation } from "@xiayun/fresh-i18n/client";
const t = useTranslation();
t("common.actions.save"); // âœ… No props needed!

// Islands - OLD WAY (migrate away from this)
const t = translate(translationData, config);
t("common.actions.save"); // âš ï¸ Legacy - requires prop-drilling
```

---

## File Organization

### Nested Structure (Recommended)

Organize translations with unlimited nesting for better maintainability:

```
locales/
â”œâ”€â”€ en/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ actions.json      â†’ common.actions.*
â”‚   â”‚   â”œâ”€â”€ states.json       â†’ common.states.*
â”‚   â”‚   â””â”€â”€ labels.json       â†’ common.labels.*
â”‚   â”œâ”€â”€ features/
â”‚   â”‚   â”œâ”€â”€ dashboard.json    â†’ features.dashboard.*
â”‚   â”‚   â””â”€â”€ users/
â”‚   â”‚       â”œâ”€â”€ list.json     â†’ features.users.list.*
â”‚   â”‚       â””â”€â”€ form.json     â†’ features.users.form.*
â””â”€â”€ es/ (same structure)
```

**File naming:**

- Use kebab-case for file names: `pdi-modals.json` â†’ auto-converts to
  `pdiModals`
- Folders become namespace levels: `features/navigator/dashboard.json` â†’
  `features.navigator.dashboard`

### Content Organization

```json
// common/actions.json
{
  "save": "Save",
  "cancel": "Cancel",
  "edit": "Edit",
  "delete": "Delete"
}

// common/states.json
{
  "loading": "Loading...",
  "saving": "Saving...",
  "success": "Success!",
  "error": "Error"
}

// features/dashboard.json
{
  "title": "Dashboard",
  "welcomeMessage": "Welcome to your dashboard",
  "stats": {
    "users": "Total Users",
    "revenue": "Revenue"
  }
}
```

---

## Usage Patterns

### 1. Routes (Server-side)

```tsx
import { define } from "@/utils.ts";

export default define.page(function MyRoute({ state }) {
  const t = state.t;
  const locale = state.locale;

  return (
    <div>
      <h1>{t("features.dashboard.title")}</h1>
      <button>{t("common.actions.save")}</button>
    </div>
  );
});
```

### 2. Islands - NEW RECOMMENDED WAY (Client-side Injection)

**Configuration Required:**

```tsx
// main.ts
app.use(i18n({
  languages: ["en", "es"],
  defaultLanguage: "en",
  localesDir: "./locales",
  clientLoad: { // ğŸ”‘ Enable client-side injection
    always: ["common"],
    routes: {
      "/indicators/*": ["features.indicators"],
      "/admin/*": ["features.admin"],
    },
    fallback: "none", // Best for gradual migration
  },
}));
```

**Island Component (Zero Props!):**

```tsx
import { useLocale, useTranslation } from "@xiayun/fresh-i18n/client";

export default function MyIsland() {
  const t = useTranslation(); // âœ¨ No props needed!
  const locale = useLocale();

  return (
    <div>
      <button>{t("common.actions.save")}</button>
      <p>Language: {locale}</p>
    </div>
  );
}
```

**Route Component (No Handler Needed!):**

```tsx
export default function MyRoute({ state }) {
  return (
    <div>
      <h1>{state.t("features.dashboard.title")}</h1>
      <MyIsland /> {/* No props! */}
    </div>
  );
}
```

**Benefits:**

- âœ… 90% payload reduction (50KB â†’ 5KB)
- âœ… No prop-drilling
- âœ… No handler boilerplate
- âœ… Cleaner code

### 3. Islands - OLD WAY (Legacy - Migrate Away)

âš ï¸ **This approach is being phased out. Migrate to the client-side injection approach above.**

See [Migration Guide](../MIGRATION_GUIDE.md) for step-by-step instructions with zero duplication.

<details>
<summary>Legacy Prop-Based Pattern (Click to expand)</summary>

**Route Handler:**

```tsx
export const handler = define.handlers({
  GET(ctx) {
    return {
      data: {
        translationData: ctx.state.translationData,
        translationConfig: {
          locale: ctx.state.locale,
          defaultLocale: ctx.state.translationConfig?.defaultLocale,
          fallbackKeys: Array.from(
            ctx.state.translationConfig?.fallbackKeys ?? [],
          ),
        },
      },
    };
  },
});
```

**Route Component:**

```tsx
export default function MyRoute({ data, state }) {
  return (
    <MyIsland
      translationData={data.translationData}
      translationConfig={data.translationConfig}
    />
  );
}
```

**Island:**

```tsx
import { translate, TranslationConfig } from "@xiayun/fresh-i18n";

interface Props {
  translationData: Record<string, unknown>;
  translationConfig?: {
    locale?: string;
    defaultLocale?: string;
    fallbackKeys?: string[];
  };
}

export default function MyIsland(
  { translationData, translationConfig }: Props,
) {
  const config: TranslationConfig | undefined = translationConfig
    ? {
      ...translationConfig,
      fallbackKeys: new Set(translationConfig.fallbackKeys ?? []),
    }
    : undefined;

  const t = translate(translationData ?? {}, config);

  return <button>{t("common.actions.save")}</button>;
}
```

</details>

### 4. Namespaced Translators (Works with Both Approaches)

Avoid repetitive namespace prefixes:

```tsx
import { createNamespacedTranslator } from "@xiayun/fresh-i18n";

export default function MyComponent({ state }) {
  const t = state.t; // Or: const t = useTranslation() in islands

  // Create scoped translators
  const tActions = createNamespacedTranslator(t, "common.actions");
  const tStates = createNamespacedTranslator(t, "common.states");
  const tDashboard = createNamespacedTranslator(t, "features.dashboard");

  return (
    <div>
      <button>{tActions("save")}</button> {/* â†’ t("common.actions.save") */}
      <button>{tActions("cancel")}</button> {/* â†’ t("common.actions.cancel") */}
      <p>{tStates("loading")}</p> {/* â†’ t("common.states.loading") */}
      <h1>{tDashboard("title")}</h1> {/* â†’ t("features.dashboard.title") */}
    </div>
  );
}
```

**Nested namespacing:**

```tsx
const tFeatures = createNamespacedTranslator(t, "features");
const tDashboard = createNamespacedTranslator(tFeatures, "dashboard");

tDashboard("title"); // â†’ t("features.dashboard.title")
```

---

## Best Practices

### âœ… DO

1. **Reuse common keys** - Check for existing translations before creating new
   ones
2. **Use namespaced translators** - Eliminate repetitive prefixes
3. **Organize by feature** - Group related translations in folders
4. **Add to both EN and ES** - Always maintain both language files
5. **Use descriptive keys** - `goalBaseline` not `field1`
6. **Test both locales** - Verify translations work in all languages

### âŒ DON'T

1. **Don't duplicate translations** - Reuse `common.actions.save` instead of
   creating `myFeature.save`
2. **Don't use partial paths** - Always use full namespace:
   `common.actions.save` not `actions.save`
3. **Don't hardcode strings** - Always use translation keys
4. **Don't forget Spanish** - Every EN key needs an ES translation
5. **Don't create flat structures** - Use nested folders for organization
6. **Don't skip maxLength** - Always add maxLength to inputs matching backend
   limits

---

## Key Organization Strategy

### Common Namespace

Truly shared strings used across multiple features:

- `common.actions.*` - Universal actions (save, cancel, edit, delete)
- `common.states.*` - Loading/success/error states
- `common.labels.*` - Generic form labels (name, description, date)
- `common.navigation.*` - Nav items, breadcrumbs
- `common.messages.*` - Generic user messages

### Feature Namespaces

Domain-specific translations:

- `features.dashboard.*` - Dashboard-specific strings
- `features.users.*` - User management
- `features.settings.*` - Settings page

### Benefits

- **No confusion** - Clear where each translation belongs
- **Easy to find** - Logical organization by feature
- **Scalable** - Add new features without bloating common
- **Maintainable** - Delete feature folder when removing a feature

---

## Troubleshooting

### Missing Translation Key Warning

```
âŒ Missing translation key: "common.actions.save"
```

**Fix:**

1. Check the key exists in both `en/` and `es/` locale files
2. Verify the full path is correct (including all parent namespaces)
3. Ensure the file structure matches the namespace path

### "Translation data not found" Error (New Client-Side Approach)

```
Error: Translation data not found. Make sure you have configured clientLoad...
```

**Fix:**

1. Add `clientLoad` configuration to your plugin setup
2. Add route pattern for the current page: `"/your-route/*": ["namespace"]`
3. Or use `fallback: "all"` to load all translations everywhere
4. Or continue using the legacy prop-based approach for that route

### TypeScript Errors in Islands (Legacy Approach)

Islands cannot receive `state.t` as props (functions can't be serialized in Fresh 2.x).

**Fix:**

- **Recommended:** Migrate to `useTranslation()` approach (see pattern #2)
- **Alternative:** Pass `translationData` and `translationConfig` as shown in legacy pattern

### Wrong Translations Showing

If you see the wrong language or fallback indicators:

**Fix:**

1. Check `state.locale` value matches expected locale
2. Verify translation files exist for that locale
3. Check fallback configuration in plugin setup

### Duplication During Migration

If you're seeing translations loaded twice (in script + props):
NEW: Client-side injection (recommended)
clientLoad: {
always: ["common"], // Load on every page
routes: {
"/indicators/_": ["features.indicators"],
"/admin/_": ["features.admin"],
},
fallback: "none", // Best for gradual migration
ignoreTrailingSlash: true,
warnOnOverlap: true,
},

    // Optional: Show fallback indicators in production
    fallback: {
        enabled: true,
        showIndicator: true,
        indicatorFormat: (text, locale) => `${text} [${locale}]`,
    },

}));

```
---

## Migration Path

**For existing apps using prop-based approach:**

1. âœ… Enable `clientLoad` with `fallback: "none"`
2. âœ… Migrate routes one at a time
3. âœ… Test each route before moving to next
4. âœ… Zero duplication during migration
5. âœ… See 90% payload reduction per migrated route

**Complete guide:** [Migration Guide](../MIGRATION_GUIDE.md)tsx
// main.ts
import { i18n } from "@xiayun/fresh-i18n";

app.use(i18n({
    languages: ["en", "es"],
    defaultLanguage: "en",
    localesDir: "./locales",

    // Optional: Show fallback indicators in production
    fallback: {
        enabled: true,
        showIndicator: true,
        indicatorFormat: (text, locale) => `${text} [${locale}]`,
    },
}));
```

---

## Reference

Full documentation:
[fresh-i18n GitHub](https://github.com/ocean-kelp/fresh-i18n)
